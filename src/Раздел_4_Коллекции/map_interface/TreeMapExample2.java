package Раздел_4_Коллекции.map_interface;

import java.util.TreeMap;

public class TreeMapExample2 {

    public static void main(String[] args) {
        TreeMap<Student, Double> treeMap = new TreeMap<>();
        TreeMap<Student, Double> treeMap2 = new TreeMap<>(Student::compareTo);
        Student st2 = new Student("Мария", "Иванова", 1);
        Student st1 = new Student("Заур", "Тройников", 3);
        Student st4 = new Student("Игорь", "Сидоров", 2);
        Student st3 = new Student("Сергей", "Петров", 4);
        Student st6 = new Student("Саша", "Капустина", 3);
        Student st5 = new Student("Василий", "Смирнов", 1);
        Student st7 = new Student("Елена", "Сидорова", 4);
        Student st8 = new Student("Елена", "Сидорова", 4);
        treeMap.put(st1, 5.8);
        treeMap.put(st7, 9.1);
        treeMap.put(st2, 6.4);
        treeMap.put(st4, 7.5);
        treeMap.put(st3, 7.2);
        treeMap.put(st6, 8.2);
        treeMap.put(st5, 7.9);
        treeMap2.put(st8, 10.10);
        System.out.println("treeMap = " + treeMap);
        System.out.println("treeMap2 = " + treeMap2);
    }

}
/*
Элементами TreeMap являются пары ключ/значение.
В TreeMap элементы хранятся в отсортированном по возрастанию порядке.
TreeMap использует совершенно другой способ хранения элементов, нежели HashMap.
Сортировка по ключу, а не по значению.
В основе TreeMap лежит красно-чёрное дерево. Это позволяет методам работать быстро, но не быстрее, чем методы HashMap.
Значения в TreeMap могут быть не уникальными.
Уникальность ключей в TreeMap поддерживается!
descendingMap - мы можем развернуть наш TreeMap в обратную сторону. По убыванию.
tailMap - выше определённого критерия.
headMap - ниже определённого критерия.
lastEntry - мы выводим элемент, который находиться в самом конце.
firstEntry - мы выводим элемент, который находиться в самом начале.
Основная цель использования TreeMap это нахождение каких-то range(отрезков). Допустим нам нужно найти студентов, у
которых балл выше, чем 7.3
Мы не можем в качестве ключа использовать класс, не реализующий интерфейс Comparable
У Double, Integer, String интерфейс Comparable реализован
Есть второй способ создания TreeMap, используя Comparator, когда в качестве ключа подаётся наш класс
        TreeMap<Student, Double> treeMap2 = new TreeMap<>(new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return o1.name.compareTo(o2.name);
            }
        });

При работе с TreeMap НЕТ НЕОБХОДИМОСТИ ПЕРЕОПРЕДЕЛЯТЬ hashcode и equals для объекта ключа.
Потому, что все поиски, добавления, и другие операции идут при помощи compareTo метода, но это правило не относится к
значениям элементам TreeMap. Например, при работе с методом containsValue(), будет возвращено false, если объекты
одинаковые, так как equals будет использоваться, а hashcode не будет использоваться вообще, но хорошим тоном будет
всегда их переопределять.

Красно-чёрное дерево (Red-Black Tree) один из видов самобалансирующихся двоичных деревьев поиска, то есть он двоичный
и самобалансирующийся
Пример, как выглядят разные деревья
Если деревья содержат целочисленные значения
                                     ----13----     (Это корень дерева)
                                    /          \
                                   8___________29      (это вершины)
                                /  |  \        /
                               1   3   5      15 ----  (это вершина)
                                            /   \    \
                                          14    20    25(Это листья)

Называют деревом, потому, что если перевернуть всё на 180 градусов, это будет корнем, есть вершины,
все элементами называются вершинами.
Вершины не имеющие потомков, называются листьями.
Есть двоичные деревья - это деревья, когда у каждой вершины может быть только 2 потомка.
То есть максимум по два потомка, один тоже может быть. Пример
                   ----50----
                  /          \
                 10          80
               /   \       /    \
             3______15____75____100

У двоичных может отсутствовать баланс.
                       5.8--
                            \
                            6.4
                               \
                                7.2
                                  \
                                   7.5
                                     \
                                     7.9
                                       \
                                       8.2
                                         \
                                         9.1


Вот так себя поведёт красно-черное дерево
                   -----7.5-----
                  /             \
                6.4             8.2
              /     \         /    \
             5.8    7.2     7.9    9.1

containsKey(), get(), put(), remove() обрабатываются за O(log(n))
TreeMap не является синхронизированной коллекцией. Коллекцию нужно синхронизировать самому вручную.
*/